BFS:

// https://practice.geeksforgeeks.org/problems/bfs-traversal-of-graph/1/?track=sp-graph&batchId=152

uses boolean visited[] and queue

outer
visit every node which is not visited(to handle disconnected graphs)

inner
1. mark node as visited, push it into queue
2. pop elements from queue till it is empty
3. for each element get its adjacency list
3. if these adjacent elements are not visited then add them to the queue and MARK THEM AS VISITED otherise they will be
inserted into the stack again


    static ArrayList<Integer> bfs(ArrayList<ArrayList<Integer>> g, int N) {
        boolean visited[] = new boolean[N];
        ArrayList<Integer> res= new ArrayList<Integer>();
        for(int i=0; i<N;++i){
            if(!visited[i])
                 innerBfs(i, g, visited, res);
        }
        return res;
    }

    static void innerBfs(int x, ArrayList<ArrayList<Integer>> g, boolean visited[], ArrayList<Integer> res ) {
        Deque<Integer> q= new LinkedList<Integer>();
        ArrayList<Integer> res= new ArrayList<Integer>();
        q.add(0);
        boolean visited[]=new boolean[v];
        visited[0]=true;
        while(st.size()!=0){
            int x=q.pollFirst();
            res.add(x);
            for(int y:g.get(x))
                if(visited[y]==false)
                    {
                        q.addLast(y);
                        visited[y]=true;
                    }
        }
        return res;
    }

------------------------------------------------------------------------------------------------------------------------
DFS:

// https://practice.geeksforgeeks.org/problems/depth-first-traversal-for-a-graph/1/?track=sp-graph&batchId=152

uses boolean visited[] and recursion
outer
visit every node which is not visited(to handle disconnected graphs)

inner
1. mark node as visited
2. get the adjacent nodes list
3. visit them if not visited by calling the same function recursively with the correct node


    static ArrayList<Integer> dfs(ArrayList<ArrayList<Integer>> g, int v){
        boolean visited[] = new boolean[N];
        ArrayList<Integer> res= new ArrayList<Integer>();
        for(int i=0; i<N;++i){
           if(!visited[i])
                innerDfs(i, g, visited, res);
        }
        return res;
    }

    static void dfsInner(ArrayList<ArrayList<Integer>> g, int v,boolean[]visited, ArrayList<Integer> res){
        res.add(v);
        visited[v]=true;
        for(int x: g.get(v)){
            if(visited[x]==false)
                dfsInner(g,x,visited,res);
        }
    }

------------------------------------------------------------------------------------------------------------------------

CHECK IF GRAPH IS CYCLIC

DIRECTED:

// https://practice.geeksforgeeks.org/problems/detect-cycle-in-a-directed-graph/1/?track=sp-graph&batchId=152

Uses boolean visited[] and boolean stack[]
outer
visit every node which is not visited(to handle disconnected graphs).

inner
1. check if node is already in stack(return true) or already visited(return false)
2. mark node as visited and add it to stack
3. explore it's adjacent vertices(recursively) irrespective of whether it is visited or not. Return true if any call
returns true

    public static boolean isCyclicInner(ArrayList<ArrayList<Integer>> g, int i,boolean[]visited, boolean[]stack){
        if(stack[i]==true)
            return true;
        if(visited[i]==true)
            return false;
        visited[i]=true;
        stack[i]=true;
        for(int x:g.get(i)){
            if(isCyclicInner(g,x,visited,stack))
                return true;
        }
        stack[i]=false;
        return false;
    }
---------------
UNDIRECTED

// https://practice.geeksforgeeks.org/problems/detect-cycle-in-an-undirected-graph/1/?track=sp-graph&batchId=152

Uses boolean visited[], boolean stack[], int parent
outer(same). Call func with parent as -1
inner:
Everything same. The rec call cond becomes if(i!=parent && cyclicUndirectedInner(v,i, g, visited, stack)) return true;

    public boolean cyclicUndirectedInner(int parent, int v, ArrayList<ArrayList<Integer>> g, boolean visited[], boolean stack[]){
        if(stack[v]==true)
            return true;
        if(visited[v]==true)
            return false;
        visited[v]=true;
        stack[v]=true;
        for(Integer i: g.get(v)){
            if(i!=parent && cyclicUndirectedInner(v,i, g, visited, stack))
                return true;
        }
        stack[v]=false;
        return false;
    }

------------------------------------------------------------------------------------------------------------------------

TOPOLOGICAL SORT

//https://practice.geeksforgeeks.org/problems/topological-sort/1

Topological Sorting of a graph. In DFS, we start from a vertex, we first print it and then recursively call DFS for its
adjacent vertices.
In topological sorting, we use a temporary stack. We donâ€™t print the vertex immediately, we first
recursively call topological sorting for all its adjacent vertices, then push it to a stack. Finally, print contents of
stack in LIFO order. Note that a vertex is pushed to stack only when all of its adjacent vertices (and adjacent
vertices of their adjacent vertices and so on) are already in stack.

    static int[] topoSort(ArrayList<ArrayList<Integer>> g, int v) {
        boolean visited[]= new boolean[v];
        Deque<Integer> st= new LinkedList<Integer>();
        for(int i=0;i<v;++i){
            if(!visited[i])
                topologicalSortInner(i,g,visited,st);
        }
        int ans[]=new int[v];
        int c=0;
        while(st.size()!=0)
            ans[c++]=st.pollLast();
        return ans;
    }

    public static void topologicalSortInner(int v, ArrayList<ArrayList<Integer>> g, boolean[]visited, Deque<Integer> st){
        visited[v]=true;
        for(int x:g.get(v)){
            if(!visited[x])
                topologicalSortInner(x,g,visited,st);
        }
        st.addLast(v);
    }

------------------------------------------------------------------------------------------------------------------------