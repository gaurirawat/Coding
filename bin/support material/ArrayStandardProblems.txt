
Max profit by infinite stock buy sell, Peak Valley Approach:

ref:
https://leetcode.com/articles/best-time-to-buy-and-sell-stock-ii/

problem:
Array_lc_buy_sell_stock_multiple_transactions
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/submissions/

If we analyze the graph, we notice that the points of interest are the consecutive valleys and peaks.
Mathematically speaking: Total Profit= \sum_{i}(height(peak_i)-height(valley_i))TotalProfit=âˆ‘

The key point is we need to consider every peak immediately following a valley to maximize the profit.
In case we skip one of the peaks (trying to obtain more profit), we will end up losing the profit over one of
the transactions leading to an overall lesser profit.

For example, in the above case, if we skip peak_i and valley_j trying to obtain more profit by
considering points with more difference in heights, the net profit obtained will always be lesser than the one
obtained by including them, since C will always be lesser than A+B.

 public int maxProfit(int[] pr) {
        int v=0;
        int p=0;
        int sum=0;

        int i=0;
        while(i<pr.length-1){
            while(i<pr.length-1 && pr[i]>=pr[i+1])
                i++;
            v=pr[i];
            while(i<pr.length-1 && pr[i]<=pr[i+1])
                i++;
            p=pr[i];
            sum+=(p-v);
        }
        return sum;

    }

-----------------------------------------------------------------------------------------------------------------------------

Min Jumps to reach end

Ref:
https://www.geeksforgeeks.org/minimum-number-jumps-reach-endset-2on-solution/
Problem:
Array_lc_jump_game_min_jumps
https://leetcode.com/problems/jump-game-ii/

tc= O(n) sc=O(1)

Variables to be used:
-maxReach The variable maxReach stores at all time the maximal reachable index in the array.
-step The variable step stores the number of steps we can still take(and is initialized with value at index 0, i.e. initial
number of steps)
-jump jump stores the amount of jumps necessary to reach that maximal reachable position.

Given array arr = 1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9

maxReach = arr[0]; // arr[0] = 1, so the maximum index we can reach at the moment is 1.
step = arr[0]; // arr[0] = 1, the amount of steps we can still take is also 1.
jump = 1; // we will always need to take at least one jump.
Now, starting iteration from index 1, the above values are updated as follows:
First we test whether we have reached the end of the array, in that case we just need to return the jump variable.
if (i == arr.length - 1)
    return jump;
Next we update the maxReach. This is equal to the maximum of maxReach and i+arr[i](the number of steps we can take from the current position).
maxReach = Math.max(maxReach, i+arr[i]);
We used up a step to get to the current index, so steps has to be decreased.
step--;
If no more steps are remaining (i.e. steps=0, then we must have used a jump. Therefore increase jump. Since we know that it is
possible somehow to reach maxReach, we again initialize the steps to the number of steps to reach maxReach from position i. But
before re-initializing step, we also check whether a step is becoming zero or negative. In this case, It is not possible to reach
further.
if (step == 0) {
    jump++;
    if(i>=maxReach)
       return -1;
    step = maxReach - i;
}

    public int jump(int[] arr) {
        if(arr.length<=1) return 0;

        int mxReach=arr[0], steps=arr[0], jumps=1;
        for(int i=1;i<arr.length;++i){
            if(i==arr.length-1)
                return jumps;
            mxReach= Math.max(mxReach, arr[i]+i);
            steps--;
            if(steps==0){
                jumps++;
                if(i==mxReach)
                    return -1;
                steps=mxReach-i;
            }
        }
        return -1;
    }
----------------------------------------------------------------------------------------------------------------