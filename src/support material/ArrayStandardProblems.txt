
Peak Valley Approach: Max profit by infinite stock buy sell,

ref:
https://leetcode.com/articles/best-time-to-buy-and-sell-stock-ii/

problem:
Array_lc_buy_sell_stock_multiple_transactions
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/submissions/

If we analyze the graph, we notice that the points of interest are the consecutive valleys and peaks.
Mathematically speaking: Total Profit= \sum_{i}(height(peak_i)-height(valley_i))TotalProfit=âˆ‘

The key point is we need to consider every peak immediately following a valley to maximize the profit.
In case we skip one of the peaks (trying to obtain more profit), we will end up losing the profit over one of
the transactions leading to an overall lesser profit.

For example, in the above case, if we skip peak_i and valley_j trying to obtain more profit by
considering points with more difference in heights, the net profit obtained will always be lesser than the one
obtained by including them, since C will always be lesser than A+B.

 public int maxProfit(int[] pr) {
        int v=0;
        int p=0;
        int sum=0;

        int i=0;
        while(i<pr.length-1){
            while(i<pr.length-1 && pr[i]>=pr[i+1])
                i++;
            v=pr[i];
            while(i<pr.length-1 && pr[i]<=pr[i+1])
                i++;
            p=pr[i];
            sum+=(p-v);
        }
        return sum;

    }

------------------------------------------------------------------------------------------------------------------------

Min Jumps to reach end

Ref:
https://www.geeksforgeeks.org/minimum-number-jumps-reach-endset-2on-solution/
Problem:
Array_lc_jump_game_min_jumps
https://leetcode.com/problems/jump-game-ii/

tc= O(n) sc=O(1)

Variables to be used:
-maxReach The variable maxReach stores at all time the maximal reachable index in the array.
-step The variable step stores the number of steps we can still take(and is initialized with value at index 0, i.e.
initial number of steps)
-jump jump stores the amount of jumps necessary to reach that maximal reachable position.

Given array arr = 1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9

maxReach = arr[0]; // arr[0] = 1, so the maximum index we can reach at the moment is 1.
step = arr[0]; // arr[0] = 1, the amount of steps we can still take is also 1.
jump = 1; // we will always need to take at least one jump.
Now, starting iteration from index 1, the above values are updated as follows:
First we test whether we have reached the end of the array, in that case we just need to return the jump variable.
if (i == arr.length - 1)
    return jump;
Next we update the maxReach. This is equal to the maximum of maxReach and i+arr[i](the number of steps we can take from
the current position).
maxReach = Math.max(maxReach, i+arr[i]);
We used up a step to get to the current index, so steps has to be decreased.
step--;
If no more steps are remaining (i.e. steps=0, then we must have used a jump. Therefore increase jump. Since we know that
it is possible somehow to reach maxReach, we again initialize the steps to the number of steps to reach maxReach from
position i. But before re-initializing step, we also check whether a step is becoming zero or negative. In this case,
it is not possible to reach further.
if (step == 0) {
    jump++;
    if(i>=maxReach)
       return -1;
    step = maxReach - i;
}

    public int jump(int[] arr) {
        if(arr.length<=1) return 0;

        int mxReach=arr[0], steps=arr[0], jumps=1;
        for(int i=1;i<arr.length;++i){
            if(i==arr.length-1)
                return jumps;
            mxReach= Math.max(mxReach, arr[i]+i);
            steps--;
            if(steps==0){
                jumps++;
                if(i==mxReach)
                    return -1;
                steps=mxReach-i;
            }
        }
        return -1;
    }
----------------------------------------------------------------------------------------------------------------

Sliding window: Maximum Points You Can Obtain from Cards

ref:
https://www.geeksforgeeks.org/collect-maximum-points-array-k-moves/
https://www.youtube.com/watch?v=1DkVU2i3sOA         (1:30 to 2:30)
problem:
Array_lc_max_point_you_can_obtain_from_cards
https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/

Sometimes it's not easy to identify if a problem falls under sliding window problem set.
Here it might seem like a dp problem where we have to choose elements once form the left and once from the right.
However if we notice closely there is a window more of a broken window a part of which is in the initial part and the
remaining in the latter.
Find sum of initial k elements. Now remove the innermost element form left and add innermost element to right. keep
track of max sum. repeat this until the entire of window shifts from left to right.

public int maxScore(int[] c, int k) {
        if(c.length==0||k==0) return 0;
        int sum=0;
        for(int i=0;i<k && i<c.length; ++i)
            sum+=c[i];
        if(k>=c.length)
            return sum;
        int max=sum;
        for(int i=0;i<k;++i){
            sum=sum-c[k-i-1]+c[c.length-1-i];
            max=Math.max(max,sum);
        }
        return max;
    }

-------------------------------------------------------------------------------------------------------------------

Rainwater trapping using max element on left/right technique

ref:
https://www.youtube.com/watch?v=FbGG2qpNp4U

prob:
Array_lc_rainwater_trapping
https://leetcode.com/problems/trapping-rain-water/submissions/

we are given an array containing height of bars. Find total water it can trap.
For every i find the greatest ht on the right and the left including current ht itself. Now traverse again. For each bar
the water that can be trapped in that cell is the total ht of water possible(obtained through the min of left and right
max) minus the occupied area ie. ht of the bar.

    public int trap(int[] h) {
        int lmax[]= new int[h.length];//contains the max element on left including itself
        int rmax[]= new int[h.length];//contains the max element on right including itself

        int max=0;
        for(int i=0;i<h.length;++i){
            max=Math.max(h[i],max);
            lmax[i]= max;
        }

        max=0;
        for(int i=h.length-1;i>=0;--i){
            max=Math.max(h[i],max);
            rmax[i]= max;
        }

        int sum=0;
        for(int i=0;i<h.length;++i)
            sum+= Math.min(lmax[i],rmax[i])-h[i];
        return sum;
    }
------------------------------------------------------------------------------------------------------------------------